#pragma once

// ----- (start) from linux kernel v2.6.29/arch/x86/include/asm/msr.h
/*
 * both i386 and x86_64 returns 64-bit value in edx:eax, but gcc's "A"
 * constraint has different meanings. For i386, "A" means exactly
 * edx:eax, while for x86_64 it doesn't mean rdx:rax or edx:eax. Instead,
 * it means rax *or* rdx.
 */
//  __x86_64__ is gcc/g++ specific
#if __x86_64__
#define DECLARE_ARGS(val, low, high)    unsigned low, high
#define EAX_EDX_VAL(val, low, high)     ((low) | ((uint64_t)(high) << 32))
#define EAX_EDX_ARGS(val, low, high)    "a" (low), "d" (high)
#define EAX_EDX_RET(val, low, high)     "=a" (low), "=d" (high)
#else
#define DECLARE_ARGS(val, low, high)    unsigned long long val
#define EAX_EDX_VAL(val, low, high)     (val)
#define EAX_EDX_ARGS(val, low, high)    "A" (val)
#define EAX_EDX_RET(val, low, high)     "=A" (val)
#endif
static inline uint64_t read_tsc()
{
#ifndef ANDROID
	DECLARE_ARGS(val, low, high);

	asm volatile("rdtsc" : EAX_EDX_RET(val, low, high));

	return EAX_EDX_VAL(val, low, high);
#else
	cout << "cycles not supported on ANDROID" << endl;
	exit(EXIT_FAILURE);

	/* TODO: need alternative for android */
	return 0;
#endif
}
// ----- (end) from linux kernel v2.6.29/arch/x86/include/asm/msr.h
